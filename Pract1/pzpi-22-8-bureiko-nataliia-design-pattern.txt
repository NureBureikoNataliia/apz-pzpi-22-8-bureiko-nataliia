Міністерство освіти і науки України
Харківський національний університет радіоелектроніки





Кафедра програмної інженерії




ЗВІТ
 з практичної роботи №1
з дисципліни «Архітектура програмного забезпечення»
на тему «Шаблон проєктування State (Стан)»





Виконала:                                                                      Перевірив:
студ. гр. ПЗПІ-22-8                                                       ст. викл. каф. ПІ 
Бурейко Н. М.                                                                Сокорчук І. П.





Харків 2025
1 ІСТОРІЯ ЗМІН
     
     
          У цьому розділі представлено історію внесених змін до звіту, що наведено у табл. 1.1.
          
          Таблиця 1.1 – Історія змін
№ДатаВерсія звітуОпис змін та виправлень121.05.20250.1Створено титульну сторінку221.05.20250.1Створено розділ «Завдання»321.05.20250.1Створено розділ «Опис виконаної роботи»421.05.20250.1Створено розділ «Висновки»521.05.20250.1Додано посилання на відеозапис та його хронологічний опис до додатку А621.05.20250.1Додано слайди презентації до додатку Б721.05.20250.1Додано програмний код до додатку В
     











2 ЗАВДАННЯ


     Під час виконання практичної роботи №1 з дисципліни «Архітектура програмного забезпечення» ставиться завдання вивчити шаблон проєктування State (Стан). Основною метою є зрозуміти його концепцію, дослідити особливості реалізації та проаналізувати можливості його застосування в об’єктно-орієнтованих програмних системах.
     У процесі роботи має розглядатися теоретична основа шаблону: його місце серед поведінкових патернів, основні складові та взаємозв’язки між ними. 
     Завдання зосереджене на поглибленому аналізі патерну State, формуванні практичних навичок його реалізації, а також підготовці технічної презентації для представлення результатів дослідження.

          
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
3 ОПИС ВИКОНАНОЇ РОБОТИ


     У ході практичного заняття було вивчено шаблон проєктування State, його призначення, типові сценарії використання та особливості реалізації згідно з підходами, описаними у книзі Ґамма "ООП. Патерни проєктування". Основну увагу приділено тому, як цей шаблон дозволяє динамічно змінювати поведінку об'єкта залежно від його внутрішнього стану без необхідності використовувати складні умовні оператори.
     Було детально проаналізовано UML-структуру патерна: інтерфейс стану, конкретні стани та контекст, який делегує поведінку активному об’єкту стану. Досліджено принципи розділення відповідальностей між класами, а також переваги шаблону, зокрема полегшення розширення системи, спрощення коду та підвищення його гнучкості.
     Була створена презентація (слайди розміщені у додатку Б), яка містить структурований теоретичний матеріал, діаграму класів UML, приклади використання, фрагменти коду (також розміщені у додатку В) та короткі висновки щодо переваг і доцільності використання шаблону. У результаті було закріплено розуміння шаблону State як потужного інструменту для побудови гнучких і розширюваних об’єктно-орієнтованих систем.










4 ВИСНОВКИ
     
     
     Під час виконання практичної роботи було засвоєно суть шаблону проєктування State, його структуру та призначення. Продемонстровано, як за допомогою цього шаблону можна змінювати поведінку об'єкта залежно від його стану без використання умовних операторів. Зроблено презентацію про шаблон проєктування State. Відеозапис захисту презентації можна знайти за посиланням розміщеному у додатку А.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     ДОДАТОК А
          Відеозапис доповіді на YouTube: https://youtu.be/B1m0T8Darpg
     
     
     Зміст:
     00:00 - вступ;
     00:43 - означення шаблону;
     01:09 - розгляд проблеми, яку вирішує шаблон;
     01:29 - розгляд конкретного прикладу;
     02:32 - ключові ідеї шаблону;
     03:00 - структура;
     03:47 - приклад використання шаблону;
     05:14 - переваги та недоліки;
     05:45 - розгляд ситуацій, коли треба використовувати шаблон State;
     06:02 - висновки;
     06:26 - джерела.
     
     


     
     
     
     
     
     
     
     
     
     
     ДОДАТОК Б
     Презентація



Рисунок А.1   Титульний слайд


Рисунок А.2   Зміст

Рисунок А.3   Ознайомлення з шаблоном State


Рисунок А.4   Розгляд проблеми, яку вирішує шаблон


Рисунок А.5   Приклад


Рисунок А.6   Приклад


Рисунок А.7   Ключові ідеї шаблону


Рисунок А.8   Структура

	
Рисунок А.9   Приклад використання


Рисунок А.10   Переваги та недоліки

	
Рисунок А.11   Ситуації, в яких слід застосовувати розглянутий шаблон


Рисунок А.12   Висновки

	
Рисунок А.13   Подяка за увагу


Рисунок А.14   Джерела



     ДОДАТОК В
     Код
     
     
  1 // Інтерфейс стану
  2 public interface IPhoneState
  3 {
  4     void HandleCall();
  5 }
  6
  7 // Конкретний стан — гучний режим
  8 public class NormalState : IPhoneState
  9 {
 10     public void HandleCall()
 11     {
 12         Console.WriteLine("Дзвінок лунає голосно.");
 13     }
 14 }
 15
 16 // Конкретний стан — вібрація
 17 public class VibrationState : IPhoneState
 18 {
 19     public void HandleCall()
 20     {
 21         Console.WriteLine("Телефон вібрує без звуку.");
 22     }
 23 }
 24
 25 // Конкретний стан — без звуку
 26 public class SilentState : IPhoneState
 27 {
 28     public void HandleCall()
 29     {
 30         Console.WriteLine("Телефон мовчить.");
 31     }
 32 }
 33
 34 // Контекст — телефон
 35 public class MobilePhone
 36 {
 37     private IPhoneState _state;
 38
 39     public void SetState(IPhoneState state)
 40     {
 41         _state = state;
 42     }
 43
 44     public void IncomingCall()
 45     {
 46         _state.HandleCall(); // Делегуємо виклик поточному стану
 47     }
 48 }
 49
 50 // Інтерфейс стану
 51 public interface ICoffeeState
 52 {
 53     void PressButton(CoffeeMachine context);
 54 }
 55
 56 // Стан очікування
 57 public class WaitingState : ICoffeeState
 58 {
 59     public void PressButton(CoffeeMachine context)
 60     {
 61         Console.WriteLine("Готуємо каву...");
 62         context.SetState(new BrewingState());
 63     }
 64 }
 65
 66 // Стан приготування
 67 public class BrewingState : ICoffeeState
 68 {
 69     public void PressButton(CoffeeMachine context)
 70     {
 71         Console.WriteLine("Кава вже готується. Будь ласка, зачекайте.");
 72         context.SetState(new ReadyState());
 73     }
 74 }
 75
 76 // Стан готовності
 77 public class ReadyState : ICoffeeState
 78 {
 79     public void PressButton(CoffeeMachine context)
 80     {
 81         Console.WriteLine("Заберіть каву. Повернення до стану очікування.");
 82         context.SetState(new WaitingState());
 83     }
 84 }
 85
 86 // Контекст
 87 public class CoffeeMachine
 88 {
 89     private ICoffeeState state;
 90
 91     public CoffeeMachine()
 92     {
 93         state = new WaitingState();
 94     }
 95
 96     public void SetState(ICoffeeState newState)
 97     {
 98         state = newState;
 99     }
100
101     public void PressButton()
102     {
103         state.PressButton(this);
104     }
105 }
     


