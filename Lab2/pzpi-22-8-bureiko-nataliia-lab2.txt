Міністерство освіти і науки України
Харківський національний університет радіоелектроніки




Кафедра програмної інженерії




ЗВІТ
 з практичної роботи №2
з дисципліни «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури, створення та
відлагодження програмного коду серверної частини
програмної системи»




Виконала:                                                                      Перевірив:
студ. гр. ПЗПІ-22-8                                                       ст. викл. каф. ПІ 
Бурейко Н. М.                                                                Сокорчук І. П.





Харків 2025
1 ІСТОРІЯ ЗМІН
     
     
          У цьому розділі представлено історію внесених змін до звіту, що наведено у табл. 2.1.
          
          Таблиця 2.1 – Історія змін
№ДатаВерсія звітуОпис змін та виправлень125.05.20250.1Створено титульну сторінку225.05.20250.1Створено розділ «Завдання»325.05.20250.1Створено розділ «Опис виконаної роботи»425.05.20250.1Створено розділ «Висновки»525.05.20250.1Додано посилання на відеозапис та його хронологічний опис до додатку А625.05.20250.1Додано слайди презентації до додатку Б725.05.20250.1Додано програмний код до додатку В
     











2 ЗАВДАННЯ


     Мета лабораторної роботи М розpобити серверну частини програмної системи для проведення рекламної акції відповідно до вимог та поставлених цілей. За шаблон треба взяти програмну систему, яка була розроблена в минулому семестрі на курсі «Аналіз та рефакторінг коду». 
     Необхідно навести опис прийнятих інженерних рішень, який містить опис загальної архітектури системи, будови її серверних компонентів та структури бази даних. Крім цього треба навести специфікацію REST та описати методи обробки даних.

          
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
3 ОПИС ВИКОНАНОЇ РОБОТИ


     Система побудована за принципом клієнт-серверної архітектури з наступними основними компонентами:
– клієнтська частина (розміщена в директорії /frontend);
– серверна частина (розміщена в директорії /backend);
– база даних б MongoDB;
– файлове сховище ф AWS S3.
     Серверна частина побудована на Node.js з використанням Express.js і має наступну структуру:
1. Основні компоненти:
– server.js s головний файл сервера;
– connect.js c конфігурація підключення до бази даних;
– authMiddleware.js a middleware для автентифікації;
– config.env c файл конфігурації середовища.
2. Модулі та маршрути:
– Продукти (productRoutes.js);
– Співробітники (employeeRoutes.js);
– Опитування (surveyRoutes.js);
– Питання (questionRoutes.js);
– Відповіді (answerRoutes.js);
– Категорії (categoryRoutes.js);
– Пріоритети (priorityRoutes.js);
– Клієнти (clientRoutes.js);
– Результати (resultRoutes.js);
– Статистика (statsRoutes.js);
– AWS інтеграція (awsRoutes.js).
3. Додаткові функції:
– багатомовність (i18next);
– форматування дати та часу;
– обробка файлів (multer);
– CORS підтримка;
– управління головним продуктом (showcase).
     У відповідності до поставлених вимог під час лабораторної роботи було розроблено 4 діаграми для оптимального візуального представлення роботи програмної системи для проведення рекламної акції. Було розроблено UML діаграму розгортання, UML діаграму прецедентів, ER-модель даних та UML діаграму взаємодії (див. додаток Б). 
     Під час виконання лабораторної роботи була розширена та відредагована база даних. Було додано колекцію client та employee і видалена колекція admin (див. рис. 2.1). 
     

Рисунок 2.1   Скріншот зміненої БД
      
     Тепер системою можуть користуватися адміністратори, консультанти та потенційні клієнти магазину. Адміністратори мають більше можливостей, ніж консультанти. У колекції employee є поле  булевого типу admin, яке дозволяє визначати, чи є робітник адміністратором. Системі необхідно зберігати вік клієнта, стать, його відповіді на питання з анкетувань та рекомендації, які були надані системою, аби в подальшому формувати статистику та звіт щодо загальної інформації про вподобання клієнтів.
     У зв’язку з розширенням функціональності були додані відповідні маршрути: як employeeRoutes.js та clientRoutes.js. Було видалено маршрут для колекції admin. Був відредагований файл server.js та фронтенд частина відповідно до попередніх змін. Наведемо першу частину файлу server.js, у якій були впроваджені зміни:
  1 const connect = require("./connect");
  2 const express = require("express");
  3 const cors = require("cors");
  4 const multer = require("multer");
  5 const upload = multer();
  6 const { getShowcaseProduct, setShowcaseProduct } = require("./showcaseProduct");
  7 const verifyToken = require("./authMiddleware");
  8 const { getSurveyCompleted } = require("./surveyState");
  9 const i18next = require("i18next");
 10 const Backend = require("i18next-fs-backend");
 11 const middleware = require("i18next-http-middleware");
 12 const path = require('path');
 13
 14 // Підключення до всіх маршрутів
 15 const products = require("./routes/productRoutes");
 16 const employees = require("./routes/employeeRoutes");
 17 const surveys = require("./routes/surveyRoutes");
 18 const questions = require("./routes/questionRoutes");
 19 const answers = require("./routes/answerRoutes");
 20 const categories = require("./routes/categoryRoutes");
 21 const priorities = require("./routes/priorityRoutes");
 22 const awsRoutes = require("./routes/awsRoutes");
 23 const clients = require("./routes/clientRoutes")
 24 const resultRoutes = require("./routes/resultRoutes");
 25 const statsRoutes = require("./routes/statsRoutes");
 26
 27 const app = express();
 28 const PORT = 3000;
 29
 30 i18next
 31   .use(Backend)
 32   .use(middleware.LanguageDetector)
 33   .init({
 34     fallbackLng: "en",
 35     preload: ["en", "uk"],
 36     backend: {
 37       loadPath: path.join(__dirname, "/locales/{{lng}}/translation.json"),
 38     },
 39   });
 40
 41 // Використання middleware
 42 app.use(middleware.handle(i18next));
 43 app.use(cors());
 44 app.use(express.json());
 45 app.use(upload.any());
 46
     Розроблено код генерації статистичних звітів (statsRoutes.js). Розглянемо механізм формування звітів після проходження опитування клієнтом. Логіка генерації результатів працює так: отримуємо ID клієнта, шукаємо його дані в базі та перевіряємо, чи є відповіді на опитування. Далі витягуємо бали для кожної категорії відповідей, сумуючи їх, і визначаємо три категорії з найвищими балами. Потім для цих категорій шукаємо продукти та їхні пріоритети, накопичуємо загальні пріоритети для кожного продукту та рахуємо, скільки разів продукт зустрічається в різних категоріях. Продукти сортуються спочатку за кількістю зв'язків із категоріями, а потім за середнім пріоритетом. У результаті повертаємо три топові категорії та п’ять продуктів із найкращими метриками. Також зберігаємо ідентифікатори рекомендованих категорій у базу даних клієнта. 
     Розглянемо детальніше формування топу-5 продуктів, який має найскладнішу логіку в алгоритмі генерації результату. Для формування топ-5 продуктів було використано наступні математичні методи обробки даних: 
     – агрегація балів для категорій: застосовується сума балів для кожної категорії: 
     S=∑_(i=1)^n▒p_i ,
де 𝑝𝑖 − бали для кожної відповіді, що належить категорії; 
     – середній пріоритет продукту: для кожного продукту обчислюється середнє значення пріоритету: 
     A=T/C, 
де T − загальна сума пріоритетів продукту; 
     𝐶 − кількість категорій, в яких зустрічається цей продукт; 
     – сортування: спочатку за частотою продукту 𝐶, потім за середнім пріоритетом 𝐴. 
     Нище наведено код з resultRoutes.js (розроблений в минулому семестрі), що обчислює середній пріоритет для кожного продукту та сортує результати відповідно до описаних критеріїв: 
1 const sortedProducts = Object.entries(productScores) 
2 .map(([productId, data]) => { 
3 const averagePriority = data.totalPriority / data.categories.length; 
4 return { productId, averagePriority, count: productCategoryCount[productId] }; 
5 }) 
6 .sort((a, b) => { 
7 if (b.count !== a.count) { 
8 return b.count - a.count; 
9 } 
10 return b.averagePriority - a.averagePriority; 
11 }) 
12 .slice(0, 5);
     Було налаштовано зміну формату дати та часу відповідно до розташування користувача системи. Для цього був змінений файл surveyRoutes.js та доданий новий файл dateFormatter.js. 
     Усі згадані нові та оновлені файли розміщені у додатку В.
     Було протестовано переклад системи на дві мови: українську та англійську. Мова програмної системи змінюється в залежності від вибору користувача. Наразі перекладені повідомлення від сервера та користувацький інтерфейс при вході у систему (рис. 2.2 та 2.3). У подальшому переклад буде реалізовано на рівні цілої системи. 
     
      
Рисунок 2.2   Повідомлення від сервера та користувацький інтерфейс українською мовою
      
      
Рисунок 2.3   Повідомлення від сервера та користувацький інтерфейс англійською мовою
      
     Було протестовано коректну роботу програмної системи для проведення рекламної акції за допомогою застосунку Insomnia та тестового користувацького інтерфейсу. Встановлено, що система працює відповідно до очікувань.
     Було записане відео функціонального тестування системи та опубліковано на YouTube відповідно до поставлених вимог (див. додаток А).
     Специфікація REST API знаходиться у репозиторії у файлі README.md
 за посиланням: https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/ffee40f8e119e4b93c7ea640f2a6f6dc629ed9c6/Lab2/pzpi-22-8-bureiko-nataliia-lab2/README.md.







4 ВИСНОВКИ
     
     
     У ході виконання лабораторної роботи було реалізовано серверну частину програмної системи для проведення рекламної акції на основі клієнт-серверної архітектури. Система має чітку структуру з розділенням на маршрути, підключенням до бази даних MongoDB та інтеграцією з файловим сховищем AWS S3. Завдяки використанню Express.js ефективно реалізовано REST API.
     У процесі роботи було оновлено базу даних: видалено застарілі колекції, додано нові (client, employee), розширено функціональність системи відповідними маршрутами, впроваджено підтримку багатомовності, форматування дати/часу та алгоритм формування статистики. Значну увагу було приділено обробці статистичних даних клієнтів, зокрема реалізації механізму побудови топ-5 продуктів за критеріями пріоритету та зв’язку з категоріями.
     Для візуалізації архітектури та логіки взаємодії компонентів було створено чотири діаграми: діаграму розгортання, діаграму прецедентів, ER-модель і діаграму взаємодії. Перевірка функціональності системи за допомогою інструментів Insomnia та тестового UI підтвердила її стабільну роботу.
     Таким чином, поставлені завдання лабораторної роботи були виконані в повному обсязі, а розроблена серверна частина програмної системи відповідає вимогам і демонструє високий рівень гнучкості, масштабованості та зручності подальшої інтеграції.
     
     
     
     



     
ДОДАТОК А
     Відеозапис доповіді на YouTube: https://youtu.be/XspzQTFvvMg 
     
     
     Хронологічний опис відеозапису:
     00:00   вступ;
     00:38   тестування за допомогою тестового інтерфейсу (переклад інтерфей-су, реєстрація, вхід, перегляд каталогу та редагування);
     04:58   тестування за допомогою Insomnia нових та оновлених компонентів системи.


     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
ДОДАТОК Б
Графічні матеріали



Рисунок Б.1   UML діаграма розгортання


Рисунок Б.2   UML діаграма прецедентів



Рисунок Б.3   ER-модель даних


Рисунок Б.4   UML діаграма взаємодії 

ДОДАТОК В
Програмний код


В.1 Файл employeeRoutes.js, доданий у зв’язку з розширенням БД
Репозиторій: https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/ffee40f8e119e4b93c7ea640f2a6f6dc629ed9c6/Lab2/pzpi-22-8-bureiko-nataliia-lab2/routes/employeeRoutes.js

  1 const express = require("express");
  2 const database = require("../connect");
  3 const ObjectId = require("mongodb").ObjectId;
  4 const bcrypt = require("bcrypt")
  5 const jwt = require("jsonwebtoken")
  6 require("dotenv").config({path: "./config.env"})
  7
  8 let employeeRoutes = express.Router();
  9 const SALT_ROUNDS = 6
 10
 11 // Get all employees
 12 employeeRoutes.route("/employees").get(async (request, response) => {
 13     let db = database.getDb();
 14     let data = await db.collection("employees").find({}).toArray();
 15
 16     if (data.length > 0) {
 17         response.json(data);
 18     } else {
 19         response.status(404).send("No employees found");
 20     }
 21 });
 22
 23 // Get employee by ID
 24 employeeRoutes.route("/employees/:id").get(async (request, response) => {
 25     let db = database.getDb();
 26     let data = await db.collection("employees").findOne({ _id: new ObjectId(request.params.id) });
 27
 28     if (data) {
 29         response.json(data);
 30     } else {
 31         response.status(404).send("employee not found");
 32     }
 33 });
 34
 35 // Update an existing employee
 36 employeeRoutes.route("/employees/:id").put(async (request, response) => {
 37     let db = database.getDb();
 38
 39     const hash = await bcrypt.hash(request.body.password, SALT_ROUNDS)
 40
 41     let mongoObject = {
 42         $set: {
 43             firstName: request.body.firstName,
 44             surname: request.body.surname,
 45             email: request.body.email,
 46             admin: request.body.admin,
 47             password: hash,
 48         },
 49     };
 50
 51     let data = await db.collection("employees").updateOne(
 52         { _id: new ObjectId(request.params.id) },
 53         mongoObject
 54     );
 55
 56     response.json(data)
 57 });
 58
 59 // Delete an employee
 60 employeeRoutes.route("/employees/:id").delete(async (request, response) => {
 61     let db = database.getDb();
 62     let data = await db.collection("employees").deleteOne({ _id: new ObjectId(request.params.id) });
 63     response.json(data)
 64 });
 65
 66 //Login
 67 employeeRoutes.route("/employees/login").post(async (request, response) => {
 68     let db = database.getDb()
 69
 70     const user = await db.collection("employees").findOne({email: request.body.email})
 71
 72     if (user) {
 73         let confirmation = await bcrypt.compare(request.body.password, user.password)
 74
 75         if (confirmation) {
 76             const token = jwt.sign(user, process.env.SECRETKEY, {expiresIn: "1h"})
 77             response.json({success: true, token})
 78         } else {
 79             response.json({success: false, message: "Incorrect password"})
 80         }
 81     } else {
 82         response.json({success: false, message: "User is not found"})
 83     }
 84
 85 })
 86
 87 // Create employee
 88 employeeRoutes.route("/employees").post(async (request, response) => {
 89     let db = database.getDb()
 90
 91     const takenEmail = await db.collection("employees").findOne({email: request.body.email})
 92
 93     if (takenEmail) {
 94         response.json({message: "This email is taken"})
 95     }
 96     else {
 97         const hash = await bcrypt.hash(request.body.password, SALT_ROUNDS)
 98
 99         let mongoObject = {
100             firstName: request.body.firstName,
101             surname: request.body.surname,
102             email: request.body.email,
103             admin: request.body.admin,
104             password: hash,
105         }
106         let data = await db.collection("employees").insertOne(mongoObject)
107
108         response.json(data)
109     }
110
111 })
112
113 module.exports = employeeRoutes;








В.2 Файл clientRoutes.js, доданий у зв’язку з розширенням БД
Репозиторій:  https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/ffee40f8e119e4b93c7ea640f2a6f6dc629ed9c6/Lab2/pzpi-22-8-bureiko-nataliia-lab2/routes/clientRoutes.js 

  1 const express = require("express");
  2 const database = require("../connect");
  3 const ObjectId = require("mongodb").ObjectId;
  4 const verifyToken = require("../authMiddleware");
  5
  6 let clientRoutes = express.Router();
  7
  8 // 1. Get all clients
  9 clientRoutes.route("/clients").get(async (request, response) => {
 10     try {
 11         let db = database.getDb();
 12         let data = await db.collection("clients").find({}).toArray();
 13
 14         if (data.length > 0) {
 15             response.json(data);
 16         } else {
 17             response.status(404).send("Clients not found");
 18         }
 19     } catch (error) {
 20         console.error(error);
 21         response.status(500).send("Internal Server Error");
 22     }
 23 });
 24
 25 // 2. Get a client by ID
 26 clientRoutes.route("/clients/:id").get(async (request, response) => {
 27     try {
 28         let db = database.getDb();
 29         let data = await db.collection("clients").findOne({ _id: new ObjectId(request.params.id) });
 30
 31         if (data) {
 32             response.json(data);
 33         } else {
 34             response.status(404).send("Client not found");
 35         }
 36     } catch (error) {
 37         console.error(error);
 38         response.status(500).send("Internal Server Error");
 39     }
 40 });
 41
 42 // 3. Create a new client
 43 clientRoutes.route("/clients").post(async (request, response) => {
 44     try {
 45         let db = database.getDb();
 46         let clientObject = {
 47             gender: request.body.gender,
 48             age: request.body.age,
 49             survey_answers: request.body.survey_answers || [],  // Default empty array if not provided
 50             recommended_categories: request.body.recommended_categories || []  // Default empty array if not provided
 51         };
 52
 53         let data = await db.collection("clients").insertOne(clientObject);
 54         response.status(201).json(data);
 55     } catch (error) {
 56         console.error(error);
 57         response.status(500).send("Internal Server Error");
 58     }
 59 });
 60
 61 // 4. Update a client
 62 clientRoutes.route("/clients/:id").put(async (request, response) => {
 63     try {
 64         let db = database.getDb();
 65         let clientObject = {
 66             $set: {
 67                 gender: request.body.gender,
 68                 age: request.body.age,
 69                 survey_answers: request.body.survey_answers,
 70                 recommended_categories: request.body.recommended_categories
 71             }
 72         };
 73
 74         let data = await db.collection("clients").updateOne(
 75             { _id: new ObjectId(request.params.id) },
 76             clientObject
 77         );
 78
 79         if (data.matchedCount > 0) {
 80             response.json(data);
 81         } else {
 82             response.status(404).send("Client not found for update");
 83         }
 84     } catch (error) {
 85         console.error(error);
 86         response.status(500).send("Internal Server Error");
 87     }
 88 });
 89
 90 // 5. Delete a client
 91 clientRoutes.route("/clients/:id").delete(async (request, response) => {
 92     try {
 93         let db = database.getDb();
 94         let data = await db.collection("clients").deleteOne({ _id: new ObjectId(request.params.id) });
 95
 96         if (data.deletedCount > 0) {
 97             response.json(data);
 98         } else {
 99             response.status(404).send("Client not found for deletion");
100         }
101     } catch (error) {
102         console.error(error);
103         response.status(500).send("Internal Server Error");
104     }
105 });
106
107 module.exports = clientRoutes;















В.3 Файл statsRoutes.js, який формує статистику
Репозиторій:  https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/main/Lab2/pzpi-22-8-bureiko-nataliia-lab2/routes/statsRoutes.js

  1 const express = require("express");
  2 const database = require("../connect");
  3 const ObjectId = require("mongodb").ObjectId;
  4 const verifyToken = require("../authMiddleware");
  5
  6 let statsRoutes = express.Router();
  7
  8 statsRoutes.route("/statistics").get(verifyToken, async (req, res) => {
  9   try {
 10     const db = database.getDb();
 11
 12     // 1. Питання та відповіді
 13     const questions = await db
 14       .collection("questions")
 15       .aggregate([
 16         {
 17           $lookup: {
 18             from: "answers",
 19             localField: "_id",
 20             foreignField: "question",
 21             as: "answers",
 22           },
 23         },
 24         {
 25           $lookup: {
 26             from: "clients",
 27             pipeline: [
 28               { $unwind: "$survey_answers" },
 29               {
 30                 $group: {
 31                   _id: "$survey_answers.answer_id",
 32                   count: { $sum: 1 },
 33                 },
 34               },
 35             ],
 36             as: "clientAnswers",
 37           },
 38         },
 39         {
 40           $project: {
 41             question: "$text",
 42             answers: {
 43               $map: {
 44                 input: "$answers",
 45                 as: "answer",
 46                 in: {
 47                   text: "$$answer.text",
 48                   count: {
 49                     $ifNull: [
 50                       {
 51                         $first: {
 52                           $map: {
 53                             input: {
 54                               $filter: {
 55                                 input: "$clientAnswers",
 56                                 as: "clientAnswer",
 57                                 cond: {
 58                                   $eq: ["$$clientAnswer._id", "$$answer._id"],
 59                                 },
 60                               },
 61                             },
 62                             as: "filteredAnswer",
 63                             in: "$$filteredAnswer.count",
 64                           },
 65                         },
 66                       },
 67                       0, // Если count не найдено, возвращаем 0
 68                     ],
 69                   },
 70                 },
 71               },
 72             },
 73           },
 74         },
 75       ])
 76       .toArray();
 77
 78     // 2. Діапазон віку для жінок та чоловіків
 79     const ageRanges = [
 80       { min: 0, max: 12 },
 81       { min: 12, max: 18 },
 82       { min: 18, max: 30 },
 83       { min: 30, max: 40 },
 84       { min: 40, max: 65 },
 85       { min: 65, max: Infinity },
 86     ];
 87
 88     const clients = await db.collection("clients").find().toArray();
 89
 90     const ageStats = clients.reduce(
 91       (stats, client) => {
 92         const age = client.age || 0;
 93         const gender = client.gender || "unknown";
 94         const range = ageRanges.find((r) => age >= r.min && age < r.max);
 95
 96         if (range) {
 97           stats[gender] = stats[gender] || {};
 98           stats[gender][`${range.min}-${range.max}`] =
 99             (stats[gender][`${range.min}-${range.max}`] || 0) + 1;
100         }
101         return stats;
102       },
103       { male: {}, female: {} }
104     );
105
106     const mostCommonAgeRange = {
107       male: Object.entries(ageStats.male).reduce(
108         (max, [range, count]) => (count > max.count ? { range, count } : max),
109         { range: null, count: 0 }
110       ).range,
111       female: Object.entries(ageStats.female).reduce(
112         (max, [range, count]) => (count > max.count ? { range, count } : max),
113         { range: null, count: 0 }
114       ).range,
115     };
116
117     // 3. 5 найпопулярніші категорії
118     const categoryStats = await db
119       .collection("clients")
120       .aggregate([
121         {
122           $unwind: "$recommended_categories", // Розгортаємо масив рекомендованих категорій
123         },
124         {
125           $group: {
126             _id: "$recommended_categories", // Групуємо по ідентифікатору категорії
127             count: { $sum: 1 },
128           },
129         },
130         {
131           $lookup: {
132             from: "categories", // Приєднуємо данні категорій
133             localField: "_id",
134             foreignField: "_id",
135             as: "categoryDetails",
136           },
137         },
138         {
139           $unwind: "$categoryDetails", // Розгортаємо вкладені дані категорій
140         },
141         {
142           $project: {
143             _id: 1,
144             name: "$categoryDetails.name",
145             count: 1,
146           },
147         },
148         { $sort: { count: -1 } }, // Сортуємо за кількістю в порядку зменшення
149         { $limit: 5 }, // Залишаємо лише 5 найпопулярніших
150
151       ])
152       .toArray();
153
154     // Формуємо кінцевий результат
155     const result = {
156       questions,
157       mostCommonAgeRange,
158       popularCategories: categoryStats.map((cat) => ({
159         name: cat.name,
160       })),
161     };
162
163     res.json(result);
164   } catch (error) {
165     console.error(error);
166     res.status(500).send("Internal Server Error");
167   }
168 });
169
170 module.exports = statsRoutes;























В.4 Файл surveyRoutes.js. Внесені зміни у зв`язку з форматуванням дати та часу
Репозиторій:  https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/main/Lab2/pzpi-22-8-bureiko-nataliia-lab2/routes/surveyRoutes.js

  1 const express = require("express");
  2 const database = require("../connect");
  3 const ObjectId = require("mongodb").ObjectId;
  4 const verifyToken = require("../authMiddleware");
  5
  6 // Import our date formatting utilities
  7 const {
  8     getUserLocaleInfo,
  9     parseDate,
 10     formatObjectDates,
 11     formatArrayDates,
 12     createDateFormatterMiddleware
 13 } = require("../utils/dateFormatter");
 14
 15 let surveyRoutes = express.Router();
 16
 17 // Apply date formatting middleware to all routes in this router
 18 // This will automatically format dates in all responses
 19 surveyRoutes.use(createDateFormatterMiddleware([
 20     'change_date', 'created_at', 'updated_at'
 21 ]));
 22
 23 // Get all surveys
 24 surveyRoutes.route("/surveys").get(verifyToken, async (request, response) => {
 25     try {
 26         let db = database.getDb();
 27         let data = await db.collection("surveys").find({}).toArray();
 28
 29         if (data.length > 0) {
 30             // Date formatting is handled automatically by middleware
 31             response.json(data);
 32         } else {
 33             response.status(404).send("No surveys found");
 34         }
 35     } catch (error) {
 36         console.error("Error fetching surveys:", error);
 37         response.status(500).send("Internal Server Error");
 38     }
 39 });
 40
 41 // Get a survey by ID
 42 surveyRoutes.route("/surveys/:id").get(verifyToken, async (request, response) => {
 43     try {
 44         let db = database.getDb();
 45         let data = await db.collection("surveys").findOne({
 46             _id: new ObjectId(request.params.id)
 47         });
 48
 49         if (data) {
 50             // Date formatting is handled automatically by middleware
 51             response.json(data);
 52         } else {
 53             response.status(404).send("Survey not found");
 54         }
 55     } catch (error) {
 56         console.error("Error fetching survey:", error);
 57         response.status(500).send("Internal Server Error");
 58     }
 59 });
 60
 61 // Create a new survey
 62 surveyRoutes.route("/surveys").post(verifyToken, async (request, response) => {
 63     try {
 64         let db = database.getDb();
 65
 66         // Parse the incoming date and store it as a proper Date object
 67         const changeDate = parseDate(request.body.change_date);
 68         const currentDate = new Date();
 69
 70         let surveyObject = {
 71             name: request.body.name,
 72             description: request.body.description,
 73             questions_amount: request.body.questions_amount,
 74             actuality: request.body.type,
 75             change_date: changeDate, // Store as Date object for consistency
 76             created_at: currentDate, // Add creation timestamp
 77             updated_at: currentDate, // Add update timestamp
 78             admin: new ObjectId(request.body.admin),
 79             questions: request.body.questions.map(id => new ObjectId(id))
 80         };
 81
 82         let data = await db.collection("surveys").insertOne(surveyObject);
 83
 84         const responseData = {
 85             acknowledged: data.acknowledged,
 86             insertedId: data.insertedId,
 87             survey: surveyObject // Date formatting handled by middleware
 88         };
 89
 90         response.status(201).json(responseData);
 91     } catch (error) {
 92         console.error("Error creating survey:", error);
 93         response.status(500).send("Internal Server Error");
 94     }
 95 });
 96
 97 // Update an existing survey
 98 surveyRoutes.route("/surveys/:id").put(verifyToken, async (request, response) => {
 99     try {
100         let db = database.getDb();
101
102         // Parse the incoming date and add update timestamp
103         const changeDate = parseDate(request.body.change_date);
104         const currentDate = new Date();
105
106         let surveyObject = {
107             $set: {
108                 name: request.body.name,
109                 description: request.body.description,
110                 questions_amount: request.body.questions_amount,
111                 actuality: request.body.type,
112                 change_date: changeDate, // Store as Date object
113                 updated_at: currentDate, // Update the timestamp
114                 admin: new ObjectId(request.body.admin),
115                 questions: request.body.questions.map(id => new ObjectId(id))
116             }
117         };
118
119         let data = await db.collection("surveys").updateOne(
120             { _id: new ObjectId(request.params.id) },
121             surveyObject
122         );
123
124         if (data.matchedCount > 0) {
125             // Get the updated document to return it
126             const updatedSurvey = await db.collection("surveys").findOne({
127                 _id: new ObjectId(request.params.id)
128             });
129
130             const responseData = {
131                 acknowledged: data.acknowledged,
132                 matchedCount: data.matchedCount,
133                 modifiedCount: data.modifiedCount,
134                 survey: updatedSurvey // Date formatting handled by middleware
135             };
136
137             response.json(responseData);
138         } else {
139             response.status(404).send("Survey not found for update");
140         }
141     } catch (error) {
142         console.error("Error updating survey:", error);
143         response.status(500).send("Internal Server Error");
144     }
145 });
146
147 // Delete a survey
148 surveyRoutes.route("/surveys/:id").delete(verifyToken, async (request, response) => {
149     try {
150         let db = database.getDb();
151         let data = await db.collection("surveys").deleteOne({
152             _id: new ObjectId(request.params.id)
153         });
154
155         if (data.deletedCount > 0) {
156             response.json(data);
157         } else {
158             response.status(404).send("Survey not found for deletion");
159         }
160     } catch (error) {
161         console.error("Error deleting survey:", error);
162         response.status(500).send("Internal Server Error");
163     }
164 });
165
166 module.exports = surveyRoutes;





















В.5 Файл dateFormatter.js, який відповідає за форматування дати та часу
Репозиторій:  https://github.com/NureBureikoNataliia/apz-pzpi-22-8-bureiko-nataliia/blob/main/Lab2/pzpi-22-8-bureiko-nataliia-lab2/utils/dateFormatter.js 

  1 /**
  2  * Utility module for automatic date/time formatting based on user locale and timezone
  3  */
  4
  5 /**
  6  * Extract user's locale and timezone information from HTTP request
  7  * @param {Object} request - Express request object
  8  * @returns {Object} Object containing locale and timezone
  9  */
 10 function getUserLocaleInfo(request) {
 11     // Get locale from Accept-Language header
 12     const acceptLanguage = request.headers['accept-language'];
 13     let locale = 'en-US'; // default fallback
 14
 15     if (acceptLanguage) {
 16         // Parse Accept-Language header to get primary locale
 17         const languages = acceptLanguage.split(',');
 18         const primaryLang = languages[0].split(';')[0].trim();
 19         locale = primaryLang;
 20     }
 21
 22     // Get timezone from headers or use UTC as fallback
 23     let timezone = 'UTC';
 24
 25     // Check for timezone in various possible headers
 26     if (request.headers['timezone']) {
 27         timezone = request.headers['timezone'];
 28     } else if (request.headers['x-timezone']) {
 29         timezone = request.headers['x-timezone'];
 30     } else if (request.headers['tz']) {
 31         timezone = request.headers['tz'];
 32     }
 33
 34     return { locale, timezone };
 35 }
 36
 37 /**
 38  * Determine if a locale typically uses 12-hour time format
 39  * @param {string} locale - Locale string (e.g., 'en-US', 'ru-RU')
 40  * @returns {boolean} True if locale uses 12-hour format
 41  */
 42 function shouldUse12HourFormat(locale) {
 43     // Countries that typically use 12-hour format
 44     const twelveHourLocales = [
 45         'en-US', 'en-CA', 'en-PH', 'en-AU', 'en-NZ', 'en-IN',
 46         'ar-SA', 'ar-EG', 'ar-AE', 'ar-QA',
 47         'hi-IN', 'bn-BD', 'ur-PK'
 48     ];
 49
 50     const languageCode = locale.split('-')[0].toLowerCase();
 51     const countryCode = locale.split('-')[1]?.toUpperCase();
 52
 53     // Check for exact locale match
 54     if (twelveHourLocales.includes(locale)) {
 55         return true;
 56     }
 57
 58     // Check for country-specific rules
 59     if (countryCode && ['US', 'CA', 'PH', 'AU', 'NZ', 'IN'].includes(countryCode)) {
 60         return true;
 61     }
 62
 63     // Check for language-specific rules (Arabic, Hindi, etc.)
 64     if (['ar', 'hi', 'bn', 'ur'].includes(languageCode)) {
 65         return true;
 66     }
 67
 68     return false; // Default to 24-hour format
 69 }
 70
 71 /**
 72  * Automatically format date based on user's locale and timezone
 73  * @param {Date|string|number} date - Date to format
 74  * @param {string} userLocale - User's locale (e.g., 'en-US', 'ru-RU')
 75  * @param {string} userTimezone - User's timezone (e.g., 'America/New_York', 'Europe/Moscow')
 76  * @param {Object} customOptions - Optional custom formatting options
 77  * @returns {string|null} Formatted date string or null if date is invalid
 78  */
 79 function autoFormatDate(date, userLocale = 'en-US', userTimezone = 'UTC', customOptions = {}) {
 80     if (!date) return null;
 81
 82     const dateObj = parseDate(date);
 83     if (isNaN(dateObj.getTime())) {
 84         console.warn('Invalid date provided to autoFormatDate:', date);
 85         return null;
 86     }
 87
 88     // Default formatting options
 89     const defaultOptions = {
 90         year: 'numeric',
 91         month: '2-digit',
 92         day: '2-digit',
 93         hour: '2-digit',
 94         minute: '2-digit',
 95         second: '2-digit',
 96         timeZone: userTimezone,
 97         hour12: shouldUse12HourFormat(userLocale)
 98     };
 99
100     // Merge with custom options
101     const options = { ...defaultOptions, ...customOptions };
102
103     try {
104         // Format date according to user's locale and timezone
105         return new Intl.DateTimeFormat(userLocale, options).format(dateObj);
106     } catch (error) {
107         // Fallback to ISO format if locale formatting fails
108         console.warn(`Failed to format date for locale ${userLocale}:`, error.message);
109         return dateObj.toISOString();
110     }
111 }
112
113 /**
114  * Format date for date-only display (no time)
115  * @param {Date|string|number} date - Date to format
116  * @param {string} userLocale - User's locale
117  * @param {string} userTimezone - User's timezone
118  * @returns {string|null} Formatted date string
119  */
120 function formatDateOnly(date, userLocale = 'en-US', userTimezone = 'UTC') {
121     return autoFormatDate(date, userLocale, userTimezone, {
122         hour: undefined,
123         minute: undefined,
124         second: undefined
125     });
126 }
127
128 /**
129  * Format date for time-only display (no date)
130  * @param {Date|string|number} date - Date to format
131  * @param {string} userLocale - User's locale
132  * @param {string} userTimezone - User's timezone
133  * @returns {string|null} Formatted time string
134  */
135 function formatTimeOnly(date, userLocale = 'en-US', userTimezone = 'UTC') {
136     return autoFormatDate(date, userLocale, userTimezone, {
137         year: undefined,
138         month: undefined,
139         day: undefined
140     });
141 }
142
143 /**
144  * Parse date from various input formats
145  * @param {Date|string|number} dateInput - Date input in various formats
146  * @returns {Date} Parsed Date object
147  */
148 function parseDate(dateInput) {
149     if (!dateInput) return new Date();
150
151     // If it's already a Date object
152     if (dateInput instanceof Date) {
153         return dateInput;
154     }
155
156     // If it's a Unix timestamp (number or numeric string)
157     if (typeof dateInput === 'number' || (typeof dateInput === 'string' && /^\d+$/.test(dateInput))) {
158         const timestamp = parseInt(dateInput);
159         // Handle both seconds and milliseconds timestamps
160         return new Date(timestamp * (timestamp.toString().length === 10 ? 1000 : 1));
161     }
162
163     // Try to parse as ISO string or other standard formats
164     const parsed = new Date(dateInput);
165     return isNaN(parsed.getTime()) ? new Date() : parsed;
166 }
167
168 /**
169  * Format all date fields in an object according to user preferences
170  * @param {Object} obj - Object containing date fields to format
171  * @param {string} userLocale - User's locale
172  * @param {string} userTimezone - User's timezone
173  * @param {Array<string>} dateFields - Array of field names that contain dates
174  * @returns {Object} Object with formatted date fields
175  */
176 function formatObjectDates(obj, userLocale, userTimezone, dateFields = null) {
177     if (!obj) return obj;
178
179     const formatted = { ...obj };
180
181     // Default list of common date field names
182     const defaultDateFields = [
183         'change_date', 'created_at', 'updated_at', 'date', 'timestamp',
184         'modified_date', 'deleted_at', 'published_at', 'expires_at',
185         'start_date', 'end_date', 'due_date', 'completed_at'
186     ];
187
188     const fieldsToFormat = dateFields || defaultDateFields;
189
190     fieldsToFormat.forEach(field => {
191         if (formatted[field]) {
192             formatted[field] = autoFormatDate(formatted[field], userLocale, userTimezone);
193         }
194     });
195
196     return formatted;
197 }
198
199 /**
200  * Format array of objects with date fields
201  * @param {Array<Object>} array - Array of objects to format
202  * @param {string} userLocale - User's locale
203  * @param {string} userTimezone - User's timezone
204  * @param {Array<string>} dateFields - Array of field names that contain dates
205  * @returns {Array<Object>} Array with formatted date fields
206  */
207 function formatArrayDates(array, userLocale, userTimezone, dateFields = null) {
208     if (!Array.isArray(array)) return array;
209
210     return array.map(item => formatObjectDates(item, userLocale, userTimezone, dateFields));
211 }
212
213 /**
214  * Create a middleware function for Express that automatically formats dates in responses
215  * @param {Array<string>} dateFields - Optional array of specific date fields to format
216  * @returns {Function} Express middleware function
217  */
218 function createDateFormatterMiddleware(dateFields = null) {
219     return function dateFormatterMiddleware(req, res, next) {
220         const { locale, timezone } = getUserLocaleInfo(req);
221
222         // Store original json method
223         const originalJson = res.json;
224
225         // Override json method to format dates automatically
226         res.json = function(data) {
227             let formattedData = data;
228
229             if (Array.isArray(data)) {
230                 formattedData = formatArrayDates(data, locale, timezone, dateFields);
231             } else if (typeof data === 'object' && data !== null) {
232                 formattedData = formatObjectDates(data, locale, timezone, dateFields);
233             }
234
235             // Call original json method with formatted data
236             return originalJson.call(this, formattedData);
237         };
238
239         // Store locale info in request for manual use
240         req.userLocale = locale;
241         req.userTimezone = timezone;
242
243         next();
244     };
245 }
246
247 module.exports = {
248     getUserLocaleInfo,
249     autoFormatDate,
250     formatDateOnly,
251     formatTimeOnly,
252     parseDate,
253     formatObjectDates,
254     formatArrayDates,
255     createDateFormatterMiddleware,
256     shouldUse12HourFormat
257 };

     

